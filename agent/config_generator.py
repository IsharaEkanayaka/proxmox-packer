"""Generate Terraform, Ansible, and config files from a ClusterSpec."""

from __future__ import annotations

from pathlib import Path
from .models import ClusterSpec


def _project_root() -> Path:
    """Return the project root (parent of agent/)."""
    return Path(__file__).resolve().parent.parent


# ---------------------------------------------------------------------------
# Terraform config generation
# ---------------------------------------------------------------------------

def generate_terraform_tfvars(spec: ClusterSpec, proxmox_creds: dict | None = None) -> str:
    """Generate terraform.tfvars content from a ClusterSpec."""
    lines = [
        f'# Auto-generated by proxmox-infra agent for cluster: {spec.name}',
        f'# Topology: {spec.control_plane_count} control-plane + {spec.worker_count} workers',
        f'',
    ]

    if proxmox_creds:
        lines += [
            f'proxmox_api_url          = "{proxmox_creds.get("api_url", "")}"',
            f'proxmox_api_token_id     = "{proxmox_creds.get("token_id", "")}"',
            f'proxmox_api_token_secret = "{proxmox_creds.get("token_secret", "")}"',
            f'',
        ]

    lines += [
        f'# VM Configuration',
        f'control_plane_count = {spec.control_plane_count}',
        f'worker_count        = {spec.worker_count}',
        f'vm_name_prefix      = "{spec.vm_name_prefix}"',
        f'',
        f'# Control plane sizing',
        f'cp_cores  = {spec.control_plane_spec.cores}',
        f'cp_memory = {spec.control_plane_spec.memory_mb}',
        f'',
        f'# Worker sizing',
        f'worker_cores  = {spec.worker_spec.cores}',
        f'worker_memory = {spec.worker_spec.memory_mb}',
        f'',
        f'# Networking',
        f'vm_ip_start    = {spec.ip_start}',
        f'vm_ip_prefix   = "{spec.ip_prefix}"',
        f'vm_ip_gateway  = "{spec.ip_gateway}"',
        f'vm_dns_server  = "{spec.dns_server}"',
        f'network_bridge = "{spec.network_bridge}"',
        f'',
        f'# Proxmox',
        f'target_node    = "{spec.target_node}"',
        f'template_id    = {spec.template_id}',
        f'vm_storage     = "{spec.storage}"',
        f'',
        f'# Auth',
        f'ssh_user       = "{spec.ssh_user}"',
        f'ssh_password   = "{spec.ssh_password}"',
    ]

    return "\n".join(lines) + "\n"


# ---------------------------------------------------------------------------
# Ansible inventory generation
# ---------------------------------------------------------------------------

def generate_ansible_inventory(spec: ClusterSpec) -> str:
    """Generate Ansible inventory.ini from a ClusterSpec."""
    lines = [
        f"# Auto-generated by proxmox-infra agent for cluster: {spec.name}",
        f"",
        f"[control_plane]",
    ]

    for i, ip in enumerate(spec.control_plane_ips):
        lines.append(f"{spec.vm_name_prefix}-{i + 1} ansible_host={ip}")

    lines += ["", "[workers]"]
    offset = spec.control_plane_count
    for i, ip in enumerate(spec.worker_ips):
        lines.append(f"{spec.vm_name_prefix}-{offset + i + 1} ansible_host={ip}")

    lines += [
        "",
        "[k8s:children]",
        "control_plane",
        "workers",
        "",
        "[k8s:vars]",
        f"ansible_user={spec.ssh_user}",
        f"ansible_password={spec.ssh_password}",
        "ansible_become=true",
        f"ansible_become_password={spec.ssh_password}",
        "ansible_ssh_common_args='-o StrictHostKeyChecking=no'",
    ]

    return "\n".join(lines) + "\n"


# ---------------------------------------------------------------------------
# Ansible role defaults generation
# ---------------------------------------------------------------------------

def generate_common_defaults(spec: ClusterSpec) -> str:
    """Generate ansible/roles/common/defaults/main.yml."""
    return (
        f"---\n"
        f'k8s_version_minor: "{spec.k8s_version_minor}"\n'
        f'k8s_version_full: "{spec.k8s_version_full}"\n'
        f'pod_network_cidr: "{spec.pod_network_cidr}"\n'
    )


def generate_control_plane_defaults(spec: ClusterSpec) -> str:
    """Generate ansible/roles/control_plane/defaults/main.yml."""
    return (
        f"---\n"
        f'pod_network_cidr: "{spec.pod_network_cidr}"\n'
    )


# ---------------------------------------------------------------------------
# CNI manifest generation (for non-flannel CNIs)
# ---------------------------------------------------------------------------

def generate_cni_task_override(spec: ClusterSpec) -> str | None:
    """
    If a non-flannel CNI is selected, return a replacement task snippet 
    for the control_plane role. Returns None if flannel (the default).
    """
    cni_urls = {
        "flannel": "https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml",
        "calico": "https://raw.githubusercontent.com/projectcalico/calico/v3.27.0/manifests/calico.yaml",
        "cilium": None,  # Cilium uses its own CLI installer
    }
    if spec.cni_plugin == "flannel":
        return None

    url = cni_urls.get(spec.cni_plugin)
    if url:
        return (
            f'- name: Install {spec.cni_plugin.title()} CNI plugin\n'
            f'  become: false\n'
            f'  command: kubectl apply -f {url}\n'
            f'  environment:\n'
            f'    KUBECONFIG: /home/ubuntu/.kube/config\n'
        )
    elif spec.cni_plugin == "cilium":
        return (
            f'- name: Install Cilium CLI\n'
            f'  shell: |\n'
            f'    CILIUM_CLI_VERSION=$(curl -s https://raw.githubusercontent.com/cilium/cilium-cli/main/stable.txt)\n'
            f'    curl -L --fail --remote-name-all https://github.com/cilium/cilium-cli/releases/download/${{CILIUM_CLI_VERSION}}/cilium-linux-amd64.tar.gz\n'
            f'    tar xzvf cilium-linux-amd64.tar.gz -C /usr/local/bin\n'
            f'    rm cilium-linux-amd64.tar.gz\n'
            f'  args:\n'
            f'    creates: /usr/local/bin/cilium\n'
            f'\n'
            f'- name: Install Cilium CNI\n'
            f'  become: false\n'
            f'  command: cilium install\n'
            f'  environment:\n'
            f'    KUBECONFIG: /home/ubuntu/.kube/config\n'
        )
    return None


# ---------------------------------------------------------------------------
# Add-on manifest generation
# ---------------------------------------------------------------------------

def generate_addons_playbook(spec: ClusterSpec) -> str | None:
    """Generate an ansible playbook for installing add-ons. Returns None if no add-ons."""
    if not spec.addons:
        return None

    addon_tasks = {
        "metrics-server": (
            '    - name: Install Metrics Server\n'
            '      command: kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
        ),
        "ingress-nginx": (
            '    - name: Install NGINX Ingress Controller\n'
            '      command: kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.9.5/deploy/static/provider/baremetal/deploy.yaml\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
        ),
        "dashboard": (
            '    - name: Install Kubernetes Dashboard\n'
            '      command: kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
        ),
        "prometheus": (
            '    - name: Add Prometheus Helm repo\n'
            '      command: helm repo add prometheus-community https://prometheus-community.github.io/helm-charts\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
            '      ignore_errors: true\n'
            '\n'
            '    - name: Install kube-prometheus-stack\n'
            '      command: helm install prometheus prometheus-community/kube-prometheus-stack --namespace monitoring --create-namespace\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
        ),
        "cert-manager": (
            '    - name: Install cert-manager\n'
            '      command: kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
        ),
        "metallb": (
            '    - name: Install MetalLB\n'
            '      command: kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v0.14.3/config/manifests/metallb-native.yaml\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
        ),
        "longhorn": (
            '    - name: Install Longhorn storage\n'
            '      command: kubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/v1.6.0/deploy/longhorn.yaml\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
        ),
        "argocd": (
            '    - name: Create ArgoCD namespace\n'
            '      command: kubectl create namespace argocd\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
            '      ignore_errors: true\n'
            '\n'
            '    - name: Install ArgoCD\n'
            '      command: kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml\n'
            '      environment:\n'
            '        KUBECONFIG: /home/ubuntu/.kube/config\n'
        ),
    }

    tasks = []
    for addon in spec.addons:
        if addon in addon_tasks:
            tasks.append(addon_tasks[addon])

    if not tasks:
        return None

    playbook = (
        f"---\n"
        f"# Auto-generated add-ons playbook for cluster: {spec.name}\n"
        f"- name: Install Kubernetes add-ons\n"
        f"  hosts: control_plane\n"
        f"  become: false\n"
        f"  tasks:\n"
    )
    playbook += "\n".join(tasks)
    return playbook


# ---------------------------------------------------------------------------
# Write all configs to disk
# ---------------------------------------------------------------------------

def write_configs(spec: ClusterSpec, proxmox_creds: dict | None = None, dry_run: bool = False) -> dict[str, str]:
    """
    Generate and write all configuration files.
    
    Returns a dict of {relative_path: content} for all files generated.
    If dry_run=True, files are not written to disk.
    """
    root = _project_root()
    
    files: dict[str, str] = {}

    # Terraform tfvars
    files["terraform/terraform.tfvars"] = generate_terraform_tfvars(spec, proxmox_creds)

    # Ansible inventory
    files["ansible/inventory.ini"] = generate_ansible_inventory(spec)

    # Ansible role defaults
    files["ansible/roles/common/defaults/main.yml"] = generate_common_defaults(spec)
    files["ansible/roles/control_plane/defaults/main.yml"] = generate_control_plane_defaults(spec)

    # Add-ons playbook
    addons_playbook = generate_addons_playbook(spec)
    if addons_playbook:
        files["ansible/addons.yml"] = addons_playbook

    if not dry_run:
        for rel_path, content in files.items():
            full_path = root / rel_path
            full_path.parent.mkdir(parents=True, exist_ok=True)
            full_path.write_text(content, encoding="utf-8")

    return files
